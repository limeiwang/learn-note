(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{426:function(t,e,a){"use strict";a.r(e);var s=a(52),n=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"react-基础"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-基础"}},[t._v("#")]),t._v(" React 基础")]),t._v(" "),a("h2",{attrs:{id:"生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#生命周期"}},[t._v("#")]),t._v(" 生命周期")]),t._v(" "),a("p",[t._v("生命周期主要是：挂载、销毁、更新")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 用于初始化 state")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("constructor")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 组件挂载后调用")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 可以在该函数中进行请求或者订阅")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("componentDidMount")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 组件销毁后调用")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("componentDidUnMount")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 判断是否需要更新组件，多用于组件性能优化")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("shouldComponentUpdate")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("nextProps"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" nextState")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 组件更新后调用")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("componentDidUpdate")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 渲染组件函数")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("render")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("h3",{attrs:{id:"_16版本-新生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_16版本-新生命周期"}},[t._v("#")]),t._v(" 16版本 新生命周期")]),t._v(" "),a("p",[t._v("16版本后，取消与 "),a("code",[t._v("componentWill")]),t._v(" 相关的生命周期")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/*\n    16版本 已取消的组件\n  */")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("~")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("~")]),t._v(" componentWillReceiveProps "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("~")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("~")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 将收到父组件的属性")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("~")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("~")]),t._v(" componentWillUnmount "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("~")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("~")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 将销毁")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("~")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("~")]),t._v(" componentWillUpdate "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("~")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("~")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 将更新")]),t._v("\n")])])]),a("p",[t._v("删除这些生命周期的原因是：因为这些生命周期发生在渲染的 "),a("code",[t._v("reconciliation")]),t._v(" 阶段，而这阶段是可以被打断的，所以执行的生命周期函数"),a("strong",[t._v("可能会出现调用多次")]),t._v("的情况。")]),t._v(" "),a("p",[t._v("通过新增组件来代替旧的生命周期")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getDerivedStateFromProps")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("nextProps"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" prevState")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" \n\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getSnapshotBeforeUpdate")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" \n")])])]),a("ol",[a("li",[t._v("getDerivedStateFromProps")])]),t._v(" "),a("p",[a("code",[t._v("getDerivedStateFromProps")]),t._v(" 用于替换 "),a("code",[t._v("componentWillReceiveProps")])]),t._v(" "),a("p",[t._v("该函数会在"),a("strong",[t._v("初始化")]),t._v("和"),a("strong",[t._v("update")]),t._v("时被调用。（虚拟dom之后，实际dom挂载之前）。它应该返回一个对象来更新状态，或者返回null来表明新属性不需要更新任何状态。")]),t._v(" "),a("p",[t._v("注意，如果父组件导致了组件的重新渲染，即使属性没有更新，这一方法也会被调用。如果你只想处理变化，你可能想去比较新旧值。")]),t._v(" "),a("p",[t._v("调用this.setState() 通常不会触发 getDerivedStateFromProps()。")]),t._v(" "),a("p",[t._v("因为该函数是静态函数，所以取不到 "),a("code",[t._v("this")]),t._v("，如果需要对比 "),a("code",[t._v("prevProps")]),t._v(" 需要单独在 "),a("code",[t._v("state")]),t._v(" 中维护")]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[t._v("getSnapshotBeforeUpdate")])]),t._v(" "),a("p",[a("code",[t._v("getSnapshotBeforeUpdate")]),t._v(" 用于替换 "),a("code",[t._v("componentWillUpdate")]),t._v(" ，该函数会在最新的渲染输出提交给DOM前调用（update 后 DOM 更新前），用于读取最新的 DOM 数据。")]),t._v(" "),a("p",[t._v("代替的原因：由于异步渲染，在“渲染”时期（如componentWillUpdate和render）和“提交”时期（如componentDidUpdate）间可能会存在延迟。如果一个用户在这期间做了像改变浏览器尺寸的事，"),a("strong",[t._v("从componentWillUpdate中读出的scrollHeight值将是滞后的")]),t._v("。")]),t._v(" "),a("p",[t._v("返回值作为 "),a("code",[t._v("componentDidUpdate")]),t._v(" 的第三个参数使用")]),t._v(" "),a("h3",{attrs:{id:"异步渲染"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#异步渲染"}},[t._v("#")]),t._v(" 异步渲染")]),t._v(" "),a("p",[a("strong",[t._v("异步渲染")]),t._v("分两个阶段："),a("code",[t._v("reconciliation")]),t._v("（可以打断） 和 "),a("code",[t._v("commit")]),t._v("（不能暂停，会一直更新界面直到完成）")]),t._v(" "),a("p",[t._v("Reconciliation 阶段（可译：调和/协调）")]),t._v(" "),a("ul",[a("li",[t._v("shouldComponentUpdate")]),t._v(" "),a("li",[a("s",[t._v("componentWillMount")])]),t._v(" "),a("li",[a("s",[t._v("componentWillReceiveProps")])]),t._v(" "),a("li",[a("s",[t._v("componentWillUpdate")])])]),t._v(" "),a("p",[t._v("Commit 阶段")]),t._v(" "),a("ul",[a("li",[t._v("componentDidMount")]),t._v(" "),a("li",[t._v("componentDidUpdate")]),t._v(" "),a("li",[a("s",[t._v("componentWillUnmount")])])]),t._v(" "),a("p",[t._v("因为 "),a("code",[t._v("reconciliation")]),t._v(" 阶段是可以被打断的，所以执行的生命周期函数"),a("strong",[t._v("可能会出现调用多次")]),t._v("的情况，从而引起 Bug。所以对于 reconciliation 阶段调用的几个函数，除了 shouldComponentUpdate 以外，其他都应该避免去使用。所以在 V16 中删除了shouldComponentUpdate 以外的生命周期，并且引入了新的 生命周期钩子 来解决这个问题。")]),t._v(" "),a("h3",{attrs:{id:"setstate"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#setstate"}},[t._v("#")]),t._v(" setState")]),t._v(" "),a("p",[t._v("setState：是异步的，并且多次调用会合并为一次，（类似于 "),a("code",[t._v("Object.assign({}, obj, obj)")]),t._v("）")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("  // this.state.count 初始化为 0\n  this.setState({ count: this.state.count + 1 })\n  this.setState({ count: this.state.count + 1 }, console.log)\n\n  console.log(this.state.count === 0);\n\n  setTimeout(() => {\n    console.log(this.state.count === 1);\n  }, 1)\n\n  // 通过 prevState 参数可以正确的修改\n  this.setState((prevState) => ({ count: prevState.count + 1 }))\n")])])]),a("h3",{attrs:{id:"component-和-purecomponent"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#component-和-purecomponent"}},[t._v("#")]),t._v(" Component 和 PureComponent")]),t._v(" "),a("p",[a("code",[t._v("PureComponent")]),t._v(" 和 "),a("code",[t._v("Component")]),t._v(" 的区别：")]),t._v(" "),a("ul",[a("li",[t._v("当props或者state改变时："),a("code",[t._v("PureComponent")]),t._v(" 默认在 "),a("code",[t._v("shouldComponentUpdate")]),t._v(" 中使用浅比较来判断是否需要重新渲染，")]),t._v(" "),a("li",[t._v("当props或者state改变时："),a("code",[t._v("Component")]),t._v("的组件会重新渲染。")])]),t._v(" "),a("p",[t._v("PureComponent的缺点：一些深层数据的改变可能会产生"),a("code",[t._v("shouldComponentUpdate")]),t._v("为false，导致不能更新")]),t._v(" "),a("p",[t._v("方法的不同绑定方式区别")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("  <CommentItem onClick={() => this.clickHandler(id)} />\n\n  // 综合上面的 Component 和 PureComponent 每当 父组件 render更新时，都会触发子组件获取到新的 onClick的 props，导致子组件重新渲染\n  // 解决方式：父组件之间传 this.clickHandler ，然后子组件调用 this.props.clickHandler(this.props.id)\n")])])]),a("h3",{attrs:{id:"react-切片机制-fiber"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-切片机制-fiber"}},[t._v("#")]),t._v(" React 切片机制 fiber")]),t._v(" "),a("p",[t._v("时间切片实际上是将任务分成不同的优先级，计算任务的运行时间，从而将任务分隔为，能暂停的方法在16ms以内")]),t._v(" "),a("p",[t._v("详情在 Fiber 源码解析 详细介绍")]),t._v(" "),a("h3",{attrs:{id:"jsx"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jsx"}},[t._v("#")]),t._v(" JSX")]),t._v(" "),a("p",[t._v("只支持表达式")]),t._v(" "),a("p",[t._v("JSX 代码会被 Babel 编译为 "),a("code",[t._v("React.createElement")]),t._v(" (所以jsx文件必须要引入React，不管React是否有显式使用)")]),t._v(" "),a("h3",{attrs:{id:"受控-不受控"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#受控-不受控"}},[t._v("#")]),t._v(" 受控 & 不受控")]),t._v(" "),a("p",[t._v("受控：通过 onchange 和value来控制")]),t._v(" "),a("p",[t._v("不受控：通过ref来获取")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("  // 正确的 ref使用\n    ref={(ele) => this.xxRef = ele};\n")])])]),a("h3",{attrs:{id:"router"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#router"}},[t._v("#")]),t._v(" Router")]),t._v(" "),a("blockquote",[a("p",[a("code",[t._v("create-react-app")]),t._v("默认使用"),a("code",[t._v("react-router-dom")])])]),t._v(" "),a("ul",[a("li",[a("code",[t._v("BrowserRouter")]),t._v("需要服务器支持，否则会出现"),a("code",[t._v("404")]),t._v("，")]),t._v(" "),a("li",[a("code",[t._v("HashRouter")]),t._v("比较随意（虽然不太好看）")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('  import { HashRouter as Router, Route } from "react-router-dom";\n\n  <Router>\n      <Route exact path="/" component={Home} />\n      <Route path="/exception" component={Exception} />\n      <Route path="/trade-record" component={TradeRecord} />\n      <Route path="/trade-interval" component={TradeInterval} />\n  </Router>\n')])])]),a("h3",{attrs:{id:"redux"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redux"}},[t._v("#")]),t._v(" redux")]),t._v(" "),a("p",[t._v("redux是通过发布订阅者模式实现的：")]),t._v(" "),a("p",[t._v("单向数据流")]),t._v(" "),a("ol",[a("li",[t._v("调用store.dispatch(action)提交"),a("code",[t._v("action")]),t._v("。")]),t._v(" "),a("li",[t._v("中间件 处理")]),t._v(" "),a("li",[t._v("redux store调用传入的"),a("code",[t._v("reducer")]),t._v("函数。把当前的state和action传进去。")]),t._v(" "),a("li",[t._v("根 reducer 应该把多个子 reducer 输出合并成一个单一的 "),a("code",[t._v("state")]),t._v(" 树。")]),t._v(" "),a("li",[t._v("Redux store 保存了根 reducer 返回的完整 state 树。")])]),t._v(" "),a("p",[t._v("容器组件就是使用 "),a("code",[t._v("store.subscribe()")]),t._v("从 "),a("code",[t._v("Redux state")]),t._v(" 树中读取部分数据，并通过 "),a("code",[t._v("props")]),t._v(" 来把这些数据提供给要渲染的组件。你可以手工来开发容器组件，但建议使用 React Redux 库的 "),a("code",[t._v("connect()")]),t._v(" 方法来生成，这个方法做了性能优化来避免很多不必要的重复渲染。")]),t._v(" "),a("p",[t._v("connect接收两个参数，一个"),a("code",[t._v("mapStateToProps")]),t._v(",就是把redux的"),a("code",[t._v("state")]),t._v("，转为组件的"),a("code",[t._v("Props")]),t._v("，还有一个参数是"),a("code",[t._v("mapDispatchToprops")]),t._v(",就是把"),a("code",[t._v("actions")]),t._v("的方法，转为"),a("code",[t._v("Props")]),t._v("属性函数。")]),t._v(" "),a("h2",{attrs:{id:"个性化配置"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#个性化配置"}},[t._v("#")]),t._v(" 个性化配置")]),t._v(" "),a("blockquote",[a("p",[t._v("react-create-app 个性化配置")])]),t._v(" "),a("p",[t._v("可以修改"),a("code",[t._v("react-scripts\\config")]),t._v("（很不妥哇）")]),t._v(" "),a("p",[t._v("所以啊，可以使用 "),a("a",{attrs:{href:"https://github.com/timarney/react-app-rewired",target:"_blank",rel:"noopener noreferrer"}},[t._v("react-app-rewired"),a("OutboundLink")],1),t._v(" 来解决")]),t._v(" "),a("h3",{attrs:{id:"设置别名-alias"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#设置别名-alias"}},[t._v("#")]),t._v(" 设置别名 alias")]),t._v(" "),a("ol",[a("li",[t._v("安装 react-app-rewired")]),t._v(" "),a("li",[t._v("配置启动项 "),a("code",[t._v('"start": "react-app-rewired start"')])]),t._v(" "),a("li",[t._v("添加"),a("code",[t._v("config-overrides.js")]),t._v("文件")]),t._v(" "),a("li",[t._v("添加代码")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("  const path = require('path');\n\n  function resolve(dir) {\n      return path.join(__dirname, '.', dir)\n  }\n  \n  module.exports = function override(config, env) {\n      config.resolve.alias = {\n          '@': resolve('src')\n      }\n      return config;\n  }\n")])])]),a("h3",{attrs:{id:"更改打包后静态文件路径"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#更改打包后静态文件路径"}},[t._v("#")]),t._v(" 更改打包后静态文件路径")]),t._v(" "),a("p",[t._v("在"),a("code",[t._v("package.json")]),t._v("文件添加 "),a("code",[t._v('"homepage": "/路径"')])]),t._v(" "),a("h3",{attrs:{id:"代理-http-proxy-middleware插件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#代理-http-proxy-middleware插件"}},[t._v("#")]),t._v(" 代理："),a("code",[t._v("http-proxy-middleware")]),t._v("插件")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("  const proxy = require('http-proxy-middleware');\n\n  module.exports = function (app) {\n      app.use(\n          proxy(\n              '/xyz',\n              {\n                  target: 'http://www.zmz.com/xyz',\n                  changeOrigin: true,\n                  pathRewrite: {\n                      '^/xyz': '/'   //重写接口\n                  }\n              }\n          )\n      );\n  }\n")])])]),a("h3",{attrs:{id:"react-hook"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-hook"}},[t._v("#")]),t._v(" React Hook")]),t._v(" "),a("blockquote",[a("p",[a("code",[t._v("Hook")]),t._v(" 可以在不编写 "),a("code",[t._v("class")]),t._v(" 的情况下使用 "),a("code",[t._v("state")]),t._v(" 以及其他的 React 特性。")])]),t._v(" "),a("p",[t._v("使用 Hook 的目的")]),t._v(" "),a("ol",[a("li",[t._v("解决 class 中生命周期函数经常包含不相关的逻辑，但又把相关逻辑分离到了几个不同方法中的问题。")]),t._v(" "),a("li",[t._v("功能的复用")])]),t._v(" "),a("p",[t._v("注意点：")]),t._v(" "),a("ol",[a("li",[a("strong",[t._v("Hook 在 class 内部是不起作用的。但可以用它取代 class")])]),t._v(" "),a("li",[a("strong",[t._v("只在最顶层使用 Hook。不要在循环，条件或嵌套函数中调用 Hook")])]),t._v(" "),a("li",[a("strong",[t._v("只在 React 函数中调用 Hook")])]),t._v(" "),a("li",[a("strong",[t._v("Hook 的调用顺序在每次渲染中都是相同的")]),t._v(" "),a("ul",[a("li",[t._v("由于是顺序调用，如果Hook不放在顶层，比如放在if中，会导致顺序后面的hook被提前调用")])])])]),t._v(" "),a("h5",{attrs:{id:"状态相关-usestate"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#状态相关-usestate"}},[t._v("#")]),t._v(" 状态相关：useState")]),t._v(" "),a("p",[t._v("懒惰的 state：useState传入一个函数，然后返回初始化的值。类似于cached")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("  const [state, setState] = useState(() => {\n    const initialState = someExpensiveComputation(props);\n    return initialState;\n  });\n\n")])])]),a("h5",{attrs:{id:"副作用相关-useeffect"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#副作用相关-useeffect"}},[t._v("#")]),t._v(" 副作用相关：useEffect")]),t._v(" "),a("blockquote",[a("p",[t._v("数据获取、设置订阅以及手动更改组件的 DOM 都属于副作用")])]),t._v(" "),a("ul",[a("li",[a("code",[t._v("useEffect")]),t._v("默认：第一次渲染之后和每次更新之后都会执行\n"),a("ul",[a("li",[t._v("每次运行 effect 的同时，DOM 都已经更新完毕")])])]),t._v(" "),a("li",[a("code",[t._v("effect")]),t._v("可以在一个组件中声明多个，将按照声明的顺序依次调用组件中的每一个 "),a("code",[t._v("effect")])]),t._v(" "),a("li",[a("code",[t._v("useEffect")]),t._v("也可看做 "),a("code",[t._v("componentDidMount")]),t._v("、"),a("code",[t._v("componentDidUpdate")]),t._v("、"),a("code",[t._v("componentWillUnmount")]),t._v("的组合\n"),a("ul",[a("li",[t._v("而class中副作用操作放到 "),a("code",[t._v("componentDidMount")]),t._v(" 和 "),a("code",[t._v("componentDidUpdate")]),t._v(" 函数中")])])]),t._v(" "),a("li",[t._v("可选"),a("strong",[t._v("清除机制")]),t._v("：如果在 "),a("code",[t._v("useEffect")]),t._v(" 返回函数，"),a("code",[t._v("React")]),t._v(" 将会在执行清除操作时调用该函数")]),t._v(" "),a("li",[t._v("可选"),a("strong",[t._v("跳过effect")]),t._v("："),a("code",[t._v("useEffect")]),t._v("的第二个参数可以传数组\n"),a("ul",[a("li",[t._v("在组件重新渲染的时候会比较数组中的每个值是否和以前相等，（相等就会跳过）")]),t._v(" "),a("li",[t._v("该参数对 清除机制 同样有效")]),t._v(" "),a("li",[t._v("如果第二个参数为 空数组[]，那么该"),a("code",[t._v("effect")]),t._v("只会执行一次")])])]),t._v(" "),a("li",[t._v("不能在 "),a("code",[t._v("useEffect")]),t._v(" 中做有副作用的事情")])]),t._v(" "),a("h5",{attrs:{id:"自定义-hook"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#自定义-hook"}},[t._v("#")]),t._v(" 自定义 Hook")]),t._v(" "),a("p",[t._v("定义：自定义的hook 其实就是以命名以 use开头的 function，里面正常使用 hook，然后返回state。")]),t._v(" "),a("p",[t._v("使用：使用和正常的function一致。")]),t._v(" "),a("p",[t._v("注意："),a("strong",[t._v("两个相同的Hook状态是不共享的")])]),t._v(" "),a("p",[t._v("其他Hook方法：")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("useContext")]),t._v("：接收一个 context 对象（React.createContext 的返回值）并返回该 context 的当前值。\n"),a("ul",[a("li",[t._v("当前的 context 值由上层组件中距离当前组件最近的 "),a("code",[t._v("<MyContext.Provider>")]),t._v(" 的 value prop 决定")]),t._v(" "),a("li",[t._v("当组件上层最近的 "),a("code",[t._v("<MyContext.Provider>")]),t._v(" 更新时，该 Hook 会触发重渲染")])])]),t._v(" "),a("li",[a("code",[t._v("useReducer")]),t._v("：useState 的替代方案，用在逻辑较为复杂且多个子值的情况，类型于"),a("code",[t._v("redux")])]),t._v(" "),a("li",[a("code",[t._v("useCallback")]),t._v("：依赖项改变时更新，类似于Vue的 计算属性，（useCallback(fn, deps) 相当于 useMemo(() => fn, deps)。）")]),t._v(" "),a("li",[a("code",[t._v("useMemo")]),t._v("：依赖项改变时更新，在渲染阶段执行，（可以把 useMemo 作为性能优化的手段）")]),t._v(" "),a("li",[a("code",[t._v("useRef")]),t._v("：对于一个可变的DOM元素，无论该节点如何改变 ref 会一直对应 useRef(null)的"),a("code",[t._v(".current")]),t._v("属性")]),t._v(" "),a("li",[a("code",[t._v("useImperativeHandle")]),t._v("：可以将使用ref时自定义暴露给父组件")]),t._v(" "),a("li",[a("code",[t._v("useLayoutEffect")]),t._v("：在浏览器执行绘制之前，useLayoutEffect 内部的更新计划将被同步刷新。")]),t._v(" "),a("li",[a("code",[t._v("useDebugValue")]),t._v("：在hook的debugger中使用")])]),t._v(" "),a("h2",{attrs:{id:"在react中使用-typescript"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#在react中使用-typescript"}},[t._v("#")]),t._v(" 在React中使用 Typescript")]),t._v(" "),a("h3",{attrs:{id:"在-ts-tsx-文件中引入-js-文件-库"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#在-ts-tsx-文件中引入-js-文件-库"}},[t._v("#")]),t._v(" 在 "),a("code",[t._v("Ts/Tsx")]),t._v(" 文件中引入 "),a("code",[t._v("js")]),t._v(" 文件/库")]),t._v(" "),a("p",[t._v("需要在"),a("code",[t._v(".d.ts")]),t._v(" 的声明文件中，然后用"),a("code",[t._v("三斜线指令引入")])]),t._v(" "),a("p",[t._v("以"),a("code",[t._v("create-react-app")]),t._v("为例：在"),a("code",[t._v("react-app-env.d.ts")]),t._v("文件中添加需要引入的 "),a("code",[t._v(".js")]),t._v("文件位置")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('    /// <reference types="react-scripts" />\n    /// <reference path="./utils/throttle.js" />\n')])])]),a("p",[t._v("或引入 "),a("code",[t._v(".d.ts")]),t._v(" 文件")]),t._v(" "),a("p",[t._v("例如：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("    // jquery.d.ts 文件\n    declare let $: (selector: string) => any;\n\n    // main.ts 文件\n    /// <reference path=\"./jquery.d.ts\" />\n\n    $('body').html('hello world');\n")])])]),a("p",[t._v("三斜线指令中需要注意的是 path 类型和 types 类型的区别：")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("types")]),t._v(" 类型声明的是对 "),a("code",[t._v("node_modules/@types")]),t._v(" 文件夹下的类型的依赖，不包含路径信息")]),t._v(" "),a("li",[a("code",[t._v("path")]),t._v(" 类型声明的是对本地文件的依赖，包含路径信息")])]),t._v(" "),a("h2",{attrs:{id:"学习路上的小技巧"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#学习路上的小技巧"}},[t._v("#")]),t._v(" 学习路上的小技巧")]),t._v(" "),a("h3",{attrs:{id:"为children注入样式-数据"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为children注入样式-数据"}},[t._v("#")]),t._v(" 为children注入样式/数据")]),t._v(" "),a("div",{staticClass:"language-jsx extra-class"},[a("pre",{pre:!0,attrs:{class:"language-jsx"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  React"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Children"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("map")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("children"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("child")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" childTs "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" child "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" React"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("DetailedReactHTMLElement"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("any"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" HTMLElement"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" React"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("cloneElement")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("childTs"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            className"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token template-string"}},[a("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")]),a("span",{pre:!0,attrs:{class:"token interpolation"}},[a("span",{pre:!0,attrs:{class:"token interpolation-punctuation punctuation"}},[t._v("${")]),t._v("childTs"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("props"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("className"),a("span",{pre:!0,attrs:{class:"token interpolation-punctuation punctuation"}},[t._v("}")])]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v(" self-style")]),a("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])])])}),[],!1,null,null,null);e.default=n.exports}}]);