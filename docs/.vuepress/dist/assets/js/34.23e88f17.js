(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{430:function(e,i,r){"use strict";r.r(i);var v=r(52),o=Object(v.a)({},(function(){var e=this,i=e.$createElement,r=e._self._c||i;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"promise"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#promise"}},[e._v("#")]),e._v(" Promise")]),e._v(" "),r("blockquote",[r("p",[e._v("Promise 是一个对象，它代表了一个异步操作的最终完成或者失败。")])]),e._v(" "),r("h3",{attrs:{id:"promise-概念"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#promise-概念"}},[e._v("#")]),e._v(" Promise 概念")]),e._v(" "),r("p",[e._v("一个 Promise有以下几种状态:")]),e._v(" "),r("ul",[r("li",[r("code",[e._v("pending")]),e._v(": 初始状态，既不是成功，也不是失败状态。")]),e._v(" "),r("li",[r("code",[e._v("fulfilled")]),e._v(": 意味着操作成功完成。")]),e._v(" "),r("li",[r("code",[e._v("rejected")]),e._v(": 意味着操作失败。")])]),e._v(" "),r("p",[e._v("不同于“老式”的传入回调，在使用 Promise 时，会有以下约定：")]),e._v(" "),r("ul",[r("li",[e._v("在 本轮 "),r("code",[e._v("Javascript event loop")]),e._v("（事件循环）运行完成 之前，回调函数是不会被调用。")]),e._v(" "),r("li",[e._v("通过 "),r("code",[e._v("then()")]),e._v(" 添加的回调函数总会被调用，即便它是在异步操作完成之后才被添加的函数。")]),e._v(" "),r("li",[e._v("通过多次调用 "),r("code",[e._v("then()")]),e._v("，可以添加多个回调函数，它们会按照插入顺序一个接一个独立执行。")])]),e._v(" "),r("p",[e._v("因为 Promise.prototype.then 和  Promise.prototype.catch 方法返回promise 对象， 所以它们可以被链式调用。")]),e._v(" "),r("p",[e._v("Promise的 4 个方法")]),e._v(" "),r("ol",[r("li",[e._v("Promise.all(iterable)")]),e._v(" "),r("li",[e._v("Promise.race(iterable)")]),e._v(" "),r("li",[e._v("Promise.resolve(value)")]),e._v(" "),r("li",[e._v("Promise.reject(reason)")])]),e._v(" "),r("p",[e._v("Promise的 prototype")]),e._v(" "),r("ol",[r("li",[e._v("Promise.prototype.catch(onRejected)")]),e._v(" "),r("li",[e._v("Promise.prototype.then(onFulfilled, onRejected)")]),e._v(" "),r("li",[e._v("Promise.prototype.finally(onFinally)")])]),e._v(" "),r("h3",{attrs:{id:"个人理解"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#个人理解"}},[e._v("#")]),e._v(" 个人理解")]),e._v(" "),r("p",[e._v("Promise本身是一个状态机，具有以下3个状态")]),e._v(" "),r("ul",[r("li",[e._v("pending（等待）")]),e._v(" "),r("li",[e._v("fulfilled（成功）")]),e._v(" "),r("li",[e._v("rejected（拒绝）")])]),e._v(" "),r("p",[e._v("当请求发送没有得到响应的时候为pending状态，得到响应后会resolve(决议)当前这个Promise实例,将它变为fulfilled/rejected(大部分情况会变为fulfilled)")]),e._v(" "),r("p",[e._v("当请求发生错误后会执行reject(拒绝)将这个Promise实例变为rejected状态")]),e._v(" "),r("p",[e._v("一个Promise实例的状态只能从pending => fulfilled 或者从 pending => rejected，即当一个Promise实例从pending状态改变后，就不会再改变了（不存在fulfilled => rejected 或 rejected => fulfilled）")]),e._v(" "),r("p",[e._v("而Promise实例必须主动调用then方法，才能将值从Promise实例中取出来（前提是Promise不是pending状态）")])])}),[],!1,null,null,null);i.default=o.exports}}]);