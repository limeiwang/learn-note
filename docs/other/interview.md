# 面试问题
> 总结出去面试所被问到的问题


### vue数据双向绑定原理

附上链接: https://juejin.im/post/6850418111985352711

### vue的生命周期
>浏览器有8个钩子，但是node中做服务端渲染的时候只有beforeCreate和created
1. `beforeCreate`是new Vue()之后触发的第一个钩子，在当前阶段data、methods、computed以及watch上的数据和方法`都不能`被访问。
2. `created`在实例创建完成后发生，当前阶段已经完成了`数据观测`，也就是可以使用数据，更改数据，在这里更改数据不会触发`updated函数`。可以做一些初始数据的获取，在当前阶段`无法与Dom进行交互`，如果非要想，可以通过`vm.$nextTick`来访问Dom。
3. `beforeMount`发生在`挂载之前`，在这之前template模板已导入渲染函数编译。而当前阶段`虚拟Dom`已经创建完成，即将开始渲染。在此时也可以对数据进行更改，`不会触`发updated。
4. `mounted`在`挂载完成后`发生，在当前阶段，真实的Dom`挂载完毕`，数据完成双向绑定，可以访问到`Dom节点`，使用$refs属性对Dom进行操作。
5. `beforeUpdate`发生在`更新之前`，也就是响应式数据发生更新，虚拟dom`重新渲染之前`被触发，你可以在当前阶段进行更改数据，不会造成重渲染。
6. `updated`发生在`更新完成之后`，当前阶段组件Dom已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致`无限循环`的更新。
7. `beforeDestroy`发生在`实例销毁之前`，在当前阶段实例完全可以被使用，我们可以在这时进行善后收尾工作，比如清除计时器，销毁父组件对子组件的重复监听。beforeDestroy(){Bus.$off("saveTheme")}
8. `destroyed`发生在`实例销毁之后`，这个时候只剩下了`dom空壳`。组件已被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁。

### vue的单向数据流
所有的 prop 都使得其父子 prop 之间形成了一个`单向下行绑定`：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件`意外改变`父级组件的状态，从而导致你的应用的`数据流向`变的混乱。

### v-if vs v-show
1. v-if是`真正`的条件渲染，因为它会确保在切换的过程中条件块内的事件监听器和子组件适当地被撤销和重建。
2. v-if也是`惰性`的：如果在渲染的时条件为假，则什么也不做--直到条件第一次变为真时，才会开始渲染条件块。
3. 相比之下，v-show就简单得多--不管初始条件是什么，元素总是会被渲染，并且只是简单地基于CSS进行切换。
> v-if有更高的切换开销，而v-show有更高的初始化渲染开销。因为，如果需要非常频繁地切换，则使用v-show较好；如果在运行时条件很少改变，则v-if较好。


### link标签 vs @import
1. link属于html标签，而@import是css提供的 
2. 页面被加载时，link会同时被加载，而@import引用的css会等到页面加载结束后加载。 
3. link是html标签，因此没有兼容性，而@import只有IE5以上才能识别。 
4. link方式样式的权重高于@import的。
5. link可以使用 js 动态引入，@import不行

